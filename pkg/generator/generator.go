package generator

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	sdm "github.com/jinuthankachan/sdm/sdmprotos" // Import the generated code for annotations
)

// GenerateFile generates the SDM artifacts for a single proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 {
		return
	}

	// generate Go models
	generateModels(gen, file)
	// generate SQL schema
	generateSQL(gen, file)
	// generate GORM repository
	generateRepo(gen, file)
}

func generateModels(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_sdm_model.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by sdm. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"time"`)
	g.P(")")
	g.P()

	for _, msg := range file.Messages {
		generateMessageModels(g, msg)
	}
}

func generateMessageModels(g *protogen.GeneratedFile, msg *protogen.Message) {
	modelName := msg.GoIdent.GoName

	// PII Table Structure
	g.P("type ", modelName, "Pii struct {")
	for _, field := range msg.Fields {
		opts := getFieldOptions(field)
		if opts.PrimaryKey || opts.Pii || opts.QueryIndex {
			goType := goTypeForField(field)
			g.P(field.GoName, " ", goType, " `gorm:\"column:", field.Desc.Name(), ";primaryKey\"`") // Simplified: all are PK for now in definition if needed, but really mostly ID is PK
		}
	}
	g.P("}")
	g.P()

	// Chain Table Structure (Generic per message type, though usually one global table is better,
	// requirement implies per object? 'chain_invoices' table. So yes, specific table per object type).
	g.P("type ", modelName, "Chain struct {")
	g.P("Key string `gorm:\"primaryKey;column:key\"`")
	g.P("FieldName string `gorm:\"primaryKey;column:field_name\"`")
	g.P("Version int64 `gorm:\"primaryKey;column:version;autoIncrement\"`")
	g.P("TxHash string `gorm:\"column:tx_hash\"`")
	g.P("FieldValue string `gorm:\"column:field_value\"`")
	g.P("CreatedAt time.Time `gorm:\"column:created_at\"`")
	g.P("}")
	g.P()

	// View Structure (Combined)
	// This structure should match the "View" description in requirements.
	g.P("type ", modelName, "View struct {")
	for _, field := range msg.Fields {
		goType := goTypeForField(field)
		g.P(field.GoName, " ", goType, " `gorm:\"column:", field.Desc.Name(), "\"`")

		opts := getFieldOptions(field)
		if opts.Hashed {
			// Add hashed version field
			g.P("Hashed", field.GoName, " string `gorm:\"column:hashed_", field.Desc.Name(), "\"`")
		}
	}
	g.P("TxHash string `gorm:\"column:tx_hash\"`")
	g.P("}")
	g.P()

	// TableName overrides
	g.P("func (", modelName, "Pii) TableName() string { return \"pii_", strings.ToLower(modelName), "s\" }")
	g.P("func (", modelName, "Chain) TableName() string { return \"chain_", strings.ToLower(modelName), "s\" }")
	g.P("func (", modelName, "View) TableName() string { return \"", strings.ToLower(modelName), "s\" }") // View name
	g.P()
}

func generateSQL(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_sdm_schema.sql"
	g := gen.NewGeneratedFile(filename, "")

	for _, msg := range file.Messages {
		modelName := strings.ToLower(msg.GoIdent.GoName)

		// PII Table
		g.P("CREATE TABLE IF NOT EXISTS pii_", modelName, "s (")
		pkFields := []string{}
		for _, field := range msg.Fields {
			opts := getFieldOptions(field)
			if opts.PrimaryKey || opts.Pii || opts.QueryIndex {
				sqlType := sqlTypeForField(field)
				line := fmt.Sprintf("  %s %s,", field.Desc.Name(), sqlType)
				if opts.PrimaryKey {
					pkFields = append(pkFields, string(field.Desc.Name()))
				}
				g.P(line)
			}
		}
		if len(pkFields) > 0 {
			g.P("  PRIMARY KEY (", strings.Join(pkFields, ", "), ")")
		}
		g.P(");")
		g.P()

		// Chain Table
		g.P("CREATE TABLE IF NOT EXISTS chain_", modelName, "s (")
		g.P("  key TEXT NOT NULL,")
		g.P("  field_name TEXT NOT NULL,")
		g.P("  version BIGSERIAL,")
		g.P("  tx_hash TEXT,")
		g.P("  field_value TEXT,")
		g.P("  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,")
		g.P("  PRIMARY KEY (key, field_name, version)")
		g.P(");")
		g.P()

		// View
		// Need to join PII table with latest Chain entries for each hashed field
		g.P("CREATE OR REPLACE VIEW ", modelName, "s AS")

		selects := []string{}
		joins := []string{}

		// PII table alias p
		for _, field := range msg.Fields {
			opts := getFieldOptions(field)
			colName := string(field.Desc.Name())

			if opts.PrimaryKey || opts.Pii || opts.QueryIndex {
				// Available in PII table
				selects = append(selects, fmt.Sprintf("p.%s", colName))
			} else {
				// It's a chain field
				// We need a join for this field
				alias := "c_" + colName
				joins = append(joins, fmt.Sprintf("LEFT JOIN (SELECT DISTINCT ON (key, field_name) field_value, key FROM chain_%ss WHERE field_name='%s' ORDER BY key, field_name, version DESC) %s ON p.id = %s.key", modelName, colName, alias, alias))
				selects = append(selects, fmt.Sprintf("%s.field_value AS %s", alias, colName))
			}

			if opts.Hashed {
				// Also need the hashed value
				hashedName := "hashed_" + colName
				alias := "c_" + hashedName
				joins = append(joins, fmt.Sprintf("LEFT JOIN (SELECT DISTINCT ON (key, field_name) field_value, key FROM chain_%ss WHERE field_name='%s' ORDER BY key, field_name, version DESC) %s ON p.id = %s.key", modelName, hashedName, alias, alias))
				selects = append(selects, fmt.Sprintf("%s.field_value AS %s", alias, hashedName))
			}
		}

		g.P("  SELECT")
		g.P("    ", strings.Join(selects, ",\n    "))
		g.P("  FROM pii_", modelName, "s p")
		for _, join := range joins {
			g.P("  ", join)
		}
		g.P(";")
		g.P()
	}
}

func generateRepo(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_sdm_repo.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"crypto/sha256"`)
	g.P(`	"encoding/hex"`)
	g.P(`	"fmt"`)
	g.P(`	"gorm.io/gorm"`)
	g.P(")")
	g.P()

	for _, msg := range file.Messages {
		modelName := msg.GoIdent.GoName
		// Repo Interface
		g.P("type ", modelName, "Repo struct {")
		g.P("  db *gorm.DB")
		g.P("}")
		g.P()

		g.P("func New", modelName, "Repo(db *gorm.DB) *", modelName, "Repo {")
		g.P("  return &", modelName, "Repo{db: db}")
		g.P("}")
		g.P()

		// Save
		g.P("func (r *", modelName, "Repo) Save(ctx context.Context, model *", modelName, ") error {")
		g.P("  return r.db.Transaction(func(tx *gorm.DB) error {")

		// Prepare PII Struct
		g.P("    pii := ", modelName, "Pii{")
		pkField := ""
		for _, field := range msg.Fields {
			opts := getFieldOptions(field)
			if opts.PrimaryKey {
				pkField = field.GoName
			}
			if opts.Pii || opts.PrimaryKey {
				g.P("      ", field.GoName, ": model.", field.GoName, ",")
			}
		}
		g.P("    }")
		g.P("    if err := tx.Create(&pii).Error; err != nil { return err }")
		g.P()

		// Prepare Chain Entries
		g.P("    // Save Chain Fields")
		for _, field := range msg.Fields {
			opts := getFieldOptions(field)
			// Non-PII fields go to chain
			if !opts.Pii {
				g.P("    if err := tx.Create(&", modelName, "Chain{")
				g.P("      Key: model.", pkField, ",")
				g.P("      FieldName: \"", field.Desc.Name(), "\",")
				g.P("      FieldValue: fmt.Sprintf(\"%v\", model.", field.GoName, "),") // Naive string conversion
				g.P("    }).Error; err != nil { return err }")
			}

			// Hashed fields
			if opts.Hashed {
				g.P("    // Hash ", field.GoName)
				g.P("    h_", field.GoName, " := sha256.Sum256([]byte(fmt.Sprintf(\"%v\", model.", field.GoName, ")))")
				g.P("    hashed_", field.GoName, " := hex.EncodeToString(h_", field.GoName, "[:])")
				g.P("    if err := tx.Create(&", modelName, "Chain{")
				g.P("      Key: model.", pkField, ",")
				g.P("      FieldName: \"hashed_", field.Desc.Name(), "\",")
				g.P("      FieldValue: hashed_", field.GoName, ",")
				g.P("    }).Error; err != nil { return err }")
			}
		}

		g.P("    return nil")
		g.P("  })")
		g.P("}")
		g.P()

		// Fetch
		g.P("func (r *", modelName, "Repo) Fetch(ctx context.Context, id string) (*", modelName, "View, error) {")
		g.P("  var view ", modelName, "View")
		g.P("  // GORM might not support querying Views directly with First if it doesn't know it's a table. ")
		g.P("  // But we defined TableName() to return the view name, so it should work.")
		g.P("  if err := r.db.WithContext(ctx).Where(\"id = ?\", id).First(&view).Error; err != nil {") // Asuming 'id' column exists in view
		g.P("    return nil, err")
		g.P("  }")
		g.P("  return &view, nil")
		g.P("}")
	}
}

type SdmOptions struct {
	PrimaryKey         bool
	ChainIdentifierKey bool
	Pii                bool
	QueryIndex         bool
	Hashed             bool
}

func getFieldOptions(field *protogen.Field) SdmOptions {
	opts := field.Desc.Options()

	// Helper to safe get bool
	getBool := func(ext protoreflect.ExtensionType) bool {
		if proto.HasExtension(opts, ext) {
			return proto.GetExtension(opts, ext).(bool)
		}
		return false
	}

	return SdmOptions{
		PrimaryKey:         getBool(sdm.E_PrimaryKey),
		ChainIdentifierKey: getBool(sdm.E_ChainIdentifierKey),
		Pii:                getBool(sdm.E_Pii),
		QueryIndex:         getBool(sdm.E_QueryIndex),
		Hashed:             getBool(sdm.E_Hashed),
	}
}

func goTypeForField(field *protogen.Field) string {
	// Simplified map
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int64Kind, protoreflect.Int32Kind:
		return "int64" // force int64 for simplicity in DB
	default:
		return "string"
	}
}

func sqlTypeForField(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "TEXT"
	case protoreflect.Int64Kind, protoreflect.Int32Kind:
		return "BIGINT"
	default:
		return "TEXT"
	}
}
